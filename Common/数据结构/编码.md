### 整数编码

![[Pasted image 20231213111739.png]]

1. 原码（sign-magnitude）  -  符号位 + 二进制转化得出
**负数的原码不能直接参与运算**， 为了解决这个问题，发明了反码；
2. 反码（1's complement）  -  除符号位外，其余位取反
**反码中0会产生两个编码00000000/10000000
3. 补码（2's complement）- 
byte 的取值范围 -128 - 127；
补码中特殊值 10000000     -128;

为了可以使用同样的电路处理加法和减法，无须特别处理正负零的歧义问题；简化硬件设计，提高了运算效率；

0 -> 正数    1 -> 负数

---
### 浮点数编码

![[Pasted image 20231213114557.png]]


1. 为什么取值范围远远大于同样占位4byte整数编码

2. 副作用是什么？

3. E = 0             E = 255 

---
![[Pasted image 20231213115134.png]]