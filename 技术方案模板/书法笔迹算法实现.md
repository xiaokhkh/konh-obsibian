实时贝塞尔插值的公式如下：

$$ P(t) = \sum_{i=0}^n {n\choose i} (1-t)^{n-i} t^i P_i $$

其中，$P_i$ 是控制点的坐标，$n$ 是控制点的数量减一，$t$ 是参数，通常在 $[0,1]$ 的范围内变化。$P(t)$ 是曲线在参数 $t$ 处的坐标。

这个公式基于贝塞尔曲线，它通过一系列的点来定义曲线的形状。实时贝塞尔插值的关键在于通过修改控制点的位置来实现曲线的平滑变化，从而模拟手势和笔画的变化。

$$B(t)=(1-t)^{2} Q_{0}+2 t(1-t) Q_{1}+t^{2} Q_{2}, t \in[0,0.5]$$


这个公式是二次贝塞尔曲线的参数方程式，其中 $Q_0$、$Q_1$、$Q_2$ 分别是曲线的起点、控制点和终点。该公式表示了曲线上的每个点 $B(t)$，它的位置取决于参数 $t$ 的值。当 $t=0$ 时，$B(t)$ 的位置是起点 $Q_0$，当 $t=0.5$ 时，$B(t)$ 的位置是曲线中点，当 $t=1$ 时，$B(t)$ 的位置是终点 $Q_2$。

在书法笔迹模拟中，我们可以使用该公式来模拟笔画的路径。假设我们需要模拟一条从 $Q_0$ 到 $Q_2$ 的笔画，可以使用一组控制点 $Q_1$ 来控制曲线的形状。在每个时间步长 $t_i$，我们可以使用该公式计算出路径上的点 $B(t_i)$，并将其记录下来。这样，我们就可以得到一系列点的序列，它们组成了笔画的路径。将这些点绘制到画布上，就可以得到笔画的效果。

在 Android 中，我们可以使用 Canvas 绘图 API 来渲染笔画路径。在绘图时，我们可以使用 Path 对象来存储笔画路径的点序列，并使用 Paint 对象来设置笔画的样式、颜色和宽度等属性。我们可以在 View 的 onTouchEvent() 方法中处理用户的触摸事件，使用该公式计算笔画路径上的点，并将它们添加到 Path 对象中。在 View 的 onDraw() 方法中，我们可以将 Path 对象绘制到 Canvas 上，以渲染笔画的效果。



1.  当用户按下手指时，记录下起点 $Q_0$ 的坐标，并创建一个 Path 对象来存储笔画路径的点序列。
2.  当用户移动手指时，根据手指的坐标计算控制点 $Q_1$ 和当前点 $Q_2$ 的坐标，并使用二次贝塞尔曲线的参数方程式计算出笔画路径上的点 $B(t)$，将其添加到 Path 对象中。
3.  当用户抬起手指时，根据手指的坐标计算终点 $Q_2$ 的坐标，并使用二次贝塞尔曲线的参数方程式计算出笔画路径上的点 $B(t)$，将其添加到 Path 对象中。
4.  在每次添加点到 Path 对象中后，调用 invalidate() 方法来触发 View 的重绘，以更新笔画的效果。

$$w_{n}{ }^{\prime}=\left\{\begin{array}{l} w_{\min } \\ w_{s}+\varphi \sqrt{\left(w_{\max }-w_{\min }\right)} \frac{\sum_{j=1}^{L}\left(\frac{h_{j}}{d_{n-j}} \mu\left(t_{n-j+1}-t_{n-j}\right)\right)}{\sum_{j=1}^{L} \frac{h_{j}}{d_{n-j}}} \quad(n=1) \end{array} \quad(n>1)\right.$$


$$w_{n}=w_{s}+\varphi \sqrt{\left(w_{\max }-w_{\min }\right)} \frac{\sum_{j=1}^{L}\left(\frac{h_{j}}{d_{n-j}} \mu\left(t_{n-j+1}-t_{n-j}\right)\right)}{\sum_{j=1}^{L} \frac{h_{j}}{d_{n-j}}}$$

n是路径上关键点的序号，当n>1时，使用这个公式计算关键点上的笔刷大小， $L$ 是计算窗的长度，表示当前点的笔刷大小与前 $L$ 个点的笔刷大小相关，

在笔锋模拟过程中，给定一个最小的初始值，随后的点根据最大允许的突变量 $\Delta w_{\mathrm{max}}$
进行叠加，形成由小变大的笔锋效果。由于 $\Delta w_{\mathrm{max}}$ 基于时间与距离来决定的，所以能够
通过用户运笔速度来形成不同笔划的笔锋效果。起笔速度越慢， $\Delta w_{\mathrm{max}}$ 越大，笔锋变化
率越大，起笔速度由慢变快，

在这个公式中，常量包括 $L$、$w_{\max}$ 和 $w_{\min}$，它们是预先确定的，不会随着用户输入的变化而改变。

其中，$L$ 表示计算窗的长度，决定了当前点的笔刷大小与前 $L$ 个点的笔刷大小相关，一般来说是根据实际应用场景和需求进行设置的。$w_{\max}$ 和 $w_{\min}$ 分别表示笔刷大小的最大值和最小值，也可以根据实际需求进行设置。

另外，公式中的变量需要通过用户输入获取，包括：

-   $n$：路径上关键点的序号，表示当前要计算笔刷大小的点在路径上的位置，根据用户输入的路径确定。
-   $h_j$：第 $j$ 个点与第 $n$ 个点之间的距离，根据路径中相邻点的坐标计算得出。
-   $d_{n-j}$：第 $n$ 个点到第 $n-j$ 个点的距离，根据路径中相邻点的坐标计算得出。
-   $t_{n-j+1}-t_{n-j}$：在第 $n-j$ 个点和第 $n-j+1$ 个点之间的时间间隔，需要根据用户输入的运笔速度和路径长度来计算得出。

除此之外，公式中还包括一些参数，如 $\varphi$ 和 $\mu$，也需要根据实际应用场景和需求进行设置。

---

可以对公式 $v_{n}=\frac{\sqrt{\left(x_{n}-x_{n-1}\right)^{2}+\left(y_{n}-y_{n-1}\right)^{2}}}{t_{n}-t_{n-1}}$ 进行滞后滤波，实现平滑处理。

滞后滤波是一种简单的滤波方法，其基本原理是将当前时刻的测量值与前一时刻的滤波输出值进行加权平均，从而得到新的滤波输出值。具体而言，可以使用以下公式进行滞后滤波：

$$y_{n}=\alpha x_{n}+(1-\alpha) y_{n-1}$$

其中，$x_n$ 是当前时刻的输入值，$y_n$ 是当前时刻的滤波输出值，$\alpha$ 是滤波器的权重系数，取值范围为 $0<\alpha<1$。

对于本题中的速度 $v_n$，可以将其视为输入值 $x_n$，使用滞后滤波进行平滑处理。根据滞后滤波的原理，为了减小滤波误差，需要根据具体情况选取合适的滤波器参数。可以通过多次实验，调整滤波器参数 $\alpha$ 的值，使得滤波后的速度 $v_n$ 能够较好地反映笔画轨迹的变化趋势，同时又不过分平滑。


---

$$B(t)=(1-t)^{2} Q_{0}+2 t(1-t) Q_{1}+t^{2} Q_{2}, t \in[0,0.5]$$

这是改进后的贝塞尔插值公式，其中 Q0，Q1 和 Q2 分别为贝塞尔曲线的控制点，t 的取值范围为 [0, 0.5]。根据这个公式，我们可以计算出贝塞尔曲线 B(t) 在 t 取值范围内的所有点，然后用这些点来进行重采样插值。具体来说，如果有 n 个采样点，且 n>3，则重采样插值的贝塞尔曲线 Hn-2 Hn-1 的控制点分别为 Hn-2，Pn-1 和 Pn，其中 Pn 是当前时刻实时采到的点，而 Hn-2 和 Pn-1 则是前一个重采样点和当前采样点之间的线段的端点。我们可以通过将 t 的取值范围限制在 [0, 0.5] 范围内，来计算出 Hn-2 Hn-1 上的点 Q0'，Q1' 和 Q2'，然后将 Q1' 作为 Hn-2 Hn-1 的控制点，将 Hn-2 和 Pn-1 作为 Hn-2 Hn-1 的起点和终点，从而得到一条平滑的重采样曲线。


滞后滤波法是一种数据平滑方法，用于消除数据中的高频噪声和采样波动。其中，滞后因子α为一个介于0和1之间的数。滤波后的结果可以表示为：yf = α×yt + (1-α)×yf。

对于公式$$v_{n}=\frac{\sqrt{\left(x_{n}-x_{n-1}\right)^{2}+\left(y_{n}-y_{n-1}\right)^{2}}}{t_{n}-t_{n-1}}$$可以将其改写为：

$$v_n = d_n / (t_n - t_n-1)$$

其中，d_n为x、y坐标之间的距离，即：
$${\sqrt{\left(x_{n}-x_{n-1}\right)^{2}+\left(y_{n}-y_{n-1}\right)^{2}}}$$

因此，可以使用滞后滤波法对$$d_n$$和$$v_n$$进行平滑滤波。

步骤如下：

1.初始化：$$yf_d1 = d_1, yf_v1 = v_1$$

2.对于第n个数据点：

a.计算滞后滤波后的
$$d_n：d = α×d_n + (1-α)×yf_dn-1$$

b.计算滞后滤波后的v_n：yf_vn = α×v_n + (1-α)×yf_vn-1

c.将yf_dn和yf_vn作为下一次的yf_dn-1和yf_vn-1

3.返回滤波后的yf_vn作为结果。

需要注意的是，滞后因子α的选择是关键。通常，α的值越小，滞后效果越强，但对于采样波动较严重的信号，可能需要较大的α值来平滑数据。经过多次试验，可以选择一个最优的α值来获得最好的滤波效果。



$$\sum_{j=1}^{L}$$

好的，那我们一步一步来实现这个计算笔刷宽度变化量的公式。

首先，我们需要先定义好这个公式中所涉及的各个变量，它们分别是：��wn​，��ws​，�φ，�max⁡wmax​，�min⁡wmin​，ℎ�hj​，��−�dn−j​，��−�+1tn−j+1​，��−�tn−j​。这些变量代表了笔刷宽度变化的初始值、基础值、变化系数以及与笔画长度、速度等相关的一些参数。因此，我们可以定义它们为以下变量：

`double wn;    // 笔刷宽度变化量 double ws;    // 基础宽度 double varphi;    // 变化系数 double wMax;    // 宽度上限值 double wMin;    // 宽度下限值 double[] h = new double[L];    // 笔画长度数组 double[] d = new double[L];    // 笔画速度倒数数组 double[] t = new double[L];    // 笔画的时间戳`

其中，我们还需要一个常量 �L，它代表了我们需要考虑的前几个笔画的长度和速度信息。

接下来，我们就可以使用这些变量来实现上述公式中的计算了。按照公式，可以将其分为几个部分来逐步实现。

首先，计算出公式中的分子部分：


那么我们可以将这个分子部分写成一个循环的形式：

`double numerator = 0.0; for (int j = 0; j < L; j++) {     double deltaT = Math.abs(t[n-j] - t[n-j-1]);     numerator += h[j] / d[n-j-1] * (deltaT + (t[n-j] - t[n-j-1])) / 2.0; }`

接下来，计算出公式中的分母部分：

同样，我们可以将其写成循环的形式：

`double denominator = 0.0; for (int j = 0; j < L; j++) {     denominator += h[j] / d[n-j-1]; }`

最后，将分子和分母带入公式中即可完成笔刷宽度变化量的计算：

`wn = ws + varphi * Math.sqrt(wMax - wMin) * numerator / denominator;`

以上就是使用 Java 实现笔刷宽度变化量计算公式的实现流程，希望对您有所帮助。






  





















--输入-- 用户手指路径点


1. 贝塞尔路径模型
$$B(t)=(1-t)^{2} Q_{0}+2 t(1-t) Q_{1}+t^{2} Q_{2}, t \in[0,0.5]$$
2. 笔刷宽度模型
$$v_{n}=\frac{\sqrt{\left(x_{n}-x_{n-1}\right)^{2}+\left(y_{n}-y_{n-1}\right)^{2}}}{t_{n}-t_{n-1}}$$
3.  滞后滤波法（数据平滑）

 
--输出--  带宽度信息的笔划位置点

--插值渲染--


SegmentList


onDraw

performance: only render currSegment, other save to cache bitmap be drawBitmap;


down:

	new Segment
	handler

move:

	controller Point
	- X
	- Y
	- time

	Segment.addPoint

	cacheHandler // 每380ms执行一次
	handler

	invalidate

up:






